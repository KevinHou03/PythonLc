def lcs(X, Y, m, n):
    # 基本情况：如果一个序列的长度为0，则LCS长度为0
    if m == 0 or n == 0:
        return 0
    # 如果最后一个字符相同，则这个字符一定在LCS中，递归计算前面部分的LCS长度
    elif X[m-1] == Y[n-1]:
        return 1 + lcs(X, Y, m-1, n-1)
    # 如果最后一个字符不同，则LCS是两种情况的较大者：
    # 1. 不包含X的最后一个字符和Y的最长公共子序列
    # 2. 不包含Y的最后一个字符和X的最长公共子序列
    else:
        return max(lcs(X, Y, m, n-1), lcs(X, Y, m-1, n))

# 示例
X = "ABDACE"
Y = "BADCE"
print("Length of LCS is ", lcs(X, Y, len(X), len(Y)))


def lcs(X, Y, m, n):
    # 如果任一字符串的当前索引越界，则LCS的长度为0
    if m == len(X) or n == len(Y):
        return 0
    # 如果两个字符串的当前字符相同，则LCS长度加1，并递归处理剩下的字符串
    elif X[m] == Y[n]:
        return 1 + lcs(X, Y, m+1, n+1)
    # 如果当前字符不同，递归计算两种情况的LCS长度，并取最大值
    else:
        return max(lcs(X, Y, m+1, n), lcs(X, Y, m, n+1))

# 示例
X = "AGGTAB"
Y = "GXTXAYB"
print("Length of LCS is", lcs(X, Y, 0, 0))


'''
锦标赛方法是一种高效的算法，用于找到一组元素中的最大值和次大值。它通过模拟锦标赛的方式进行，其中元素两两比较，胜者进入下一轮，
直到最后决出一个胜者。这种方法特别适用于寻找无序数组中的最大值和次大值。

### 步骤概述：

1. **配对比较**：将数组中的元素两两配对并比较，每对中的胜者进入下一轮比较。如果有奇数个元素，最后一个元素直接晋级到下一轮。

2. **迭代**：继续对每一轮的胜者进行配对和比较，直到最后只剩下一个元素，这个元素就是整个数组的最大值。

3. **寻找次大值**：回溯最大值在锦标赛中的比赛历史，即它在每一轮中胜过的元素。次大值一定在这些被最大值直接击败的元素中。比较这些元素找出最大的一个，即为次大值。

### 优点：

- **比较次数减少**：锦标赛方法找到最大值需要 \(n-1\) 次比较（每个元素除了最大值外都要输一次）。找到次大值最多需要 \(\log n - 1\) 次比较（最大值的比赛历史），
因此总比较次数约为 n + logn - 2
- **效率**：比起简单的两次遍历（一次找最大值，一次找次大值），锦标赛方法更高效，特别是当元素数量很大时。

### 缺点：

- **实现复杂度**：锦标赛方法的实现比简单遍历复杂，需要维护额外的结构来跟踪每个元素的比赛历史。
- **空间复杂度**：存储锦标赛树和每个元素的比赛历史需要额外的空间。

### 示例：

考虑一个简单的数组 \([4, 7, 2, 8, 10, 3]\)。通过锦标赛方法，我们首先比较 \(4\) 和 \(7\)，\(2\) 和 \(8\)，\(10\) 和 \(3\)，然后 \(7\)、\(8\) 和 \(10\) 进入下一轮，最后 \(10\) 胜出为最大值。在找次大值时，我们只需要比较 \(10\) 在锦标赛中直接击败的元素：\(7\)、\(8\) 和 \(3\)，发现 \(8\) 是这些元素中的最大值，因此 \(8\) 是次大值。

锦标赛方法通过减少比较次数来优化查找最大值和次大值的过程，使其比简单的线性搜索更加高效。
'''

def fibonacci_memo(n, memo={}):
    if n in memo:
        return memo[n]  # 如果之前计算过这个值，则直接从缓存中返回结果
    if n <= 2:
        return 1
    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)  # 计算当前值并存入缓存以便将来使用
    return memo[n]

# 示例：计算第10个斐波那契数
fibonacci_10 = fibonacci_memo(10)
fibonacci_10


def fibonacci_recursion(n):
    if n <= 2:
        return 1
    return fibonacci_recursion(n - 1) + fibonacci_recursion(n - 2)

# 示例：计算第10个斐波那契数
fibonacci_10 = fibonacci_recursion(10)
fibonacci_10

'''

'''
